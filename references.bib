
@inproceedings{gopstein_understanding_2017,
	address = {Paderborn, Germany},
	title = {Understanding misunderstandings in source code},
	isbn = {978-1-4503-5105-8},
	url = {http://dl.acm.org/citation.cfm?doid=3106237.3106264},
	doi = {10.1145/3106237.3106264},
	abstract = {Humans often mistake the meaning of source code, and so misjudge a program’s true behavior. These mistakes can be caused by extremely small, isolated patterns in code, which can lead to signiicant runtime errors. These patterns are used in large, popular software projects and even recommended in style guides. To identify code patterns that may confuse programmers we extracted a preliminary set of ‘atoms of confusion’ from known confusing code. We show empirically in an experiment with 73 participants that these code patterns can lead to a signiicantly increased rate of misunderstanding versus equivalent code without the patterns. We then go on to take larger confusing programs and measure (in an experiment with 43 participants) the impact, in terms of programmer confusion, of removing these confusing patterns. All of our instruments, analysis code, and data are publicly available online for replication, experimentation, and feedback.},
	language = {en},
	urldate = {2018-09-07},
	booktitle = {Proceedings of the 2017 11th {Joint} {Meeting} on {Foundations} of {Software} {Engineering}  - {ESEC}/{FSE} 2017},
	publisher = {ACM Press},
	author = {Gopstein, Dan and Iannacone, Jake and Yan, Yu and DeLong, Lois and Zhuang, Yanyan and Yeh, Martin K.-C. and Cappos, Justin},
	year = {2017},
	pages = {129--139},
	annote = {Browse Time: 1 min 57 sec, Scan; Authors are individuals that I currently work with and paper is directly in my field of interest/research.
 
Scan notes: This theoretical/experimental paper looks to address the problem of confusing code in style guides that propagated to bugs in production code. The solution that is presented is that the confusing code (atoms) can be identified and future style guides and standards may be written with the non-confusing patterns instead. The significance of this experiment is high, given that many atoms were found that were commonly used in production code and can be identified to be removed for ease of program intent.
 
Critical read. },
	file = {Gopstein et al. - 2017 - Understanding misunderstandings in source code.pdf:C\:\\Users\\Charles\\Zotero\\storage\\TAZKUC6C\\Gopstein et al. - 2017 - Understanding misunderstandings in source code.pdf:application/pdf}
}

@inproceedings{siegmund_measuring_2017,
	address = {Paderborn, Germany},
	title = {Measuring neural efficiency of program comprehension},
	isbn = {978-1-4503-5105-8},
	url = {http://dl.acm.org/citation.cfm?doid=3106237.3106268},
	doi = {10.1145/3106237.3106268},
	abstract = {Most modern software programs cannot be understood in their entirety by a single programmer. Instead, programmers must rely on a set of cognitive processes that aid in seeking, filtering, and shaping relevant information for a given programming task. Several theories have been proposed to explain these processes, such as “beacons,” for locating relevant code, and “plans,” for encoding cognitive models. However, these theories are decades old and lack validation with modern cognitive-neuroscience methods. In this paper, we report on a study using functional magnetic resonance imaging (fMRI) with 11 participants who performed program comprehension tasks. We manipulated experimental conditions related to beacons and layout to isolate specific cognitive processes related to bottom-up comprehension and comprehension based on semantic cues. We found evidence of semantic chunking during bottom-up comprehension and lower activation of brain areas during comprehension based on semantic cues, confirming that beacons ease comprehension.},
	language = {en},
	urldate = {2018-09-07},
	booktitle = {Proceedings of the 2017 11th {Joint} {Meeting} on {Foundations} of {Software} {Engineering}  - {ESEC}/{FSE} 2017},
	publisher = {ACM Press},
	author = {Siegmund, Janet and Peitek, Norman and Parnin, Chris and Apel, Sven and Hofmeister, Johannes and Kästner, Christian and Begel, Andrew and Bethmann, Anja and Brechmann, André},
	year = {2017},
	pages = {140--150},
	annote = {Browse Time: 2mins 8sec, Scan; Interesting concept and possible link to future research in cognitive code confusion.
Scan notes: This theoretical/experimental paper confirms the previous findings of other authors that semantic cues in programming is a more efficient process for understanding source code than bottom-up comprehension. The fMRI readings that resulted from this experiment are in holding with the previous researchers and shows that it is a useful measurement tool for CS research. The significance is enough to allow further study into the activation of areas of the brain with certain cues, beacons, and techniques of program layout.
 
Critical read needed.},
	file = {Siegmund et al. - 2017 - Measuring neural efficiency of program comprehensi.pdf:C\:\\Users\\Charles\\Zotero\\storage\\5JXFL3LQ\\Siegmund et al. - 2017 - Measuring neural efficiency of program comprehensi.pdf:application/pdf}
}

@inproceedings{ceccato_effectiveness_2009,
	title = {The effectiveness of source code obfuscation: {An} experimental assessment},
	shorttitle = {The effectiveness of source code obfuscation},
	doi = {10.1109/ICPC.2009.5090041},
	abstract = {Source code obfuscation is a protection mechanism widely used to limit the possibility of malicious reverse engineering or attack activities on a software system. Although several code obfuscation techniques and tools are available, little knowledge is available about the capability of obfuscation to reduce attackers' efficiency, and the contexts in which such an efficiency may vary. This paper reports the outcome of two controlled experiments meant to measure the ability of subjects to understand and modify decompiled, obfuscated Java code, compared to decompiled, clear code. Results quantify to what extent code obfuscation is able to make attacks more difficult to be performed, and reveal that obfuscation can mitigate the effect of factors that can alter the likelihood of a successful attack, such as the attackers' skill and experience, or the intrinsic characteristics of the system under attack.},
	booktitle = {2009 {IEEE} 17th {International} {Conference} on {Program} {Comprehension}},
	author = {Ceccato, M. and Penta, M. Di and Nagra, J. and Falcarin, P. and Ricca, F. and Torchiano, M. and Tonella, P.},
	month = may,
	year = {2009},
	keywords = {Java, Software systems, Application software, Automatic control, Data structures, Empirical studies, Encoding, Java code, Performance analysis, Program comprehension, Protection, protection mechanism, Reverse engineering, security of data, Software measurement, Software Obfuscation, software protection, software system, source code obfuscation techniques},
	pages = {178--187},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Charles\\Zotero\\storage\\HULBFE59\\5090041.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Charles\\Zotero\\storage\\KIEB24IY\\Ceccato et al. - 2009 - The effectiveness of source code obfuscation An e.pdf:application/pdf}
}

@inproceedings{anckaert_program_2007,
	address = {Alexandria, Virginia, USA},
	title = {Program obfuscation: a quantitative approach},
	isbn = {978-1-59593-885-5},
	shorttitle = {Program obfuscation},
	url = {http://portal.acm.org/citation.cfm?doid=1314257.1314263},
	doi = {10.1145/1314257.1314263},
	abstract = {Despite the recent advances in the theory underlying obfuscation, there still is a need to evaluate the quality of practical obfuscating transformations more quickly and easily. This paper presents the ﬁrst steps toward a comprehensive evaluation suite consisting of a number of deobfuscating transformations and complexity metrics that can be readily applied on existing and future transformations in the domain of binary obfuscation. In particular, a framework based on software complexity metrics measuring four program properties: code, control ﬂow, data and data ﬂow is suggested. A number of well-known obfuscating and deobfuscating transformations are evaluated based upon their impact on a set of complexity metrics. This enables us to quantitatively evaluate the potency of the (de)obfuscating transformations.},
	language = {en},
	urldate = {2018-09-25},
	booktitle = {Proceedings of the 2007 {ACM} workshop on {Quality} of protection  - {QoP} '07},
	publisher = {ACM Press},
	author = {Anckaert, Bertrand and Madou, Matias and De Sutter, Bjorn and De Bus, Bruno and De Bosschere, Koen and Preneel, Bart},
	year = {2007},
	pages = {15},
	file = {Anckaert et al. - 2007 - Program obfuscation a quantitative approach.pdf:C\:\\Users\\Charles\\Zotero\\storage\\4ZPY7LNQ\\Anckaert et al. - 2007 - Program obfuscation a quantitative approach.pdf:application/pdf}
}

@inproceedings{capiluppi_code_2012,
	title = {Code {Defactoring}: {Evaluating} the {Effectiveness} of {Java} {Obfuscations}},
	shorttitle = {Code {Defactoring}},
	doi = {10.1109/WCRE.2012.17},
	abstract = {Obfuscation is a very common protection against reverse engineering attacks: it modifies a program structure to make it harder for the adversary to analyse and understand it. Conceptually, obfuscation is the opposite of refactoring: the code should be more complex to understand, bloated, and with excessive characteristics from the design point of view. This paper aims at evaluating the code complexity introduced by different obfuscation algorithms by using software engineering metrics. Using structural metrics, this paper illustrates how the various types of obfuscation algorithms perform in terms of OO attributes that should be kept low in refactoring. Results show that the majority of the selected algorithms produce no changes in the structural attributes or the average complexity, but they produce more “dead” code. We argue that this could not represent the optimal way to protect the code: when protecting against reverse engineering attacks, a preference should be given to those algorithms that increase the complexity and alter the structural metrics.},
	booktitle = {2012 19th {Working} {Conference} on {Reverse} {Engineering}},
	author = {Capiluppi, A. and Falcarin, P. and Boldyreff, C.},
	month = oct,
	year = {2012},
	keywords = {Java, Software, software maintenance, Measurement, Software algorithms, reverse engineering, Arrays, code complexity, code defactoring, Complexity theory, computer crime, cyclomatic complexity, dead code, Java obfuscations, obfuscation, OO attributes, program structure modification, reverse engineering attack, security metrics, software engineering metrics, software metrics, Software protection, structural attributes, structural metrics},
	pages = {71--80},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Charles\\Zotero\\storage\\K8U5XRHR\\6385103.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Charles\\Zotero\\storage\\CMEVYAXN\\Capiluppi et al. - 2012 - Code Defactoring Evaluating the Effectiveness of .pdf:application/pdf}
}

@inproceedings{haiduc_supporting_2010,
	address = {Cape Town, South Africa},
	title = {Supporting program comprehension with source code summarization},
	volume = {2},
	isbn = {978-1-60558-719-6},
	url = {http://portal.acm.org/citation.cfm?doid=1810295.1810335},
	doi = {10.1145/1810295.1810335},
	abstract = {One of the main challenges faced by today’s developers is keeping up with the staggering amount of source code that needs to be read and understood. In order to help developers with this problem and reduce the costs associated with it, one solution is to use simple textual descriptions of source code entities that developers can grasp easily, while capturing the code semantics precisely. We propose an approach to automatically determine such descriptions, based on automated text summarization technology.},
	language = {en},
	urldate = {2018-09-26},
	booktitle = {Proceedings of the 32nd {ACM}/{IEEE} {International} {Conference} on {Software} {Engineering} - {ICSE} '10},
	publisher = {ACM Press},
	author = {Haiduc, Sonia and Aponte, Jairo and Marcus, Andrian},
	year = {2010},
	pages = {223},
	file = {Haiduc et al. - 2010 - Supporting program comprehension with source code .pdf:C\:\\Users\\Charles\\Zotero\\storage\\6RSU9AVU\\Haiduc et al. - 2010 - Supporting program comprehension with source code .pdf:application/pdf}
}

@inproceedings{gopstein_prevalence_2018,
	address = {Gothenburg, Sweden},
	title = {Prevalence of confusing code in software projects: atoms of confusion in the wild},
	isbn = {978-1-4503-5716-6},
	shorttitle = {Prevalence of confusing code in software projects},
	url = {http://dl.acm.org/citation.cfm?doid=3196398.3196432},
	doi = {10.1145/3196398.3196432},
	abstract = {Prior work has shown that extremely small code patterns, such as the conditional operator and implicit type conversion, can cause considerable misunderstanding in programmers. Until now, the real world impact of these patterns ś known as ‘atoms of confusion’ ś was only speculative. This work uses a corpus of 14 of the most popular and inluential open source C and C++ projects to measure the prevalence and signiicance of these small confusing patterns. Our results show that the 15 known types of confusing micro patterns occur millions of times in programs like the Linux kernel and GCC, appearing on average once every 23 lines. We show there is a strong correlation between these confusing patterns and bug-ix commits as well as a tendency for confusing patterns to be commented. We also explore patterns at the project level showing the rate of security vulnerabilities is higher in projects with more atoms. Finally, we examine real code examples containing these atoms, including ones that were used to ind and ix bugs in our corpus. In total this work demonstrates that beyond simple misunderstanding in the lab setting, atoms of confusion are both prevalent ś occurring often in real projects, and meaningful ś being removed by bug-ix commits at an elevated rate.},
	language = {en},
	urldate = {2018-09-26},
	booktitle = {Proceedings of the 15th {International} {Conference} on {Mining} {Software} {Repositories}  - {MSR} '18},
	publisher = {ACM Press},
	author = {Gopstein, Dan and Zhou, Hongwei Henry and Frankl, Phyllis and Cappos, Justin},
	year = {2018},
	pages = {281--291},
	file = {Gopstein et al. - 2018 - Prevalence of confusing code in software projects.pdf:C\:\\Users\\Charles\\Zotero\\storage\\MFG7J9NT\\Gopstein et al. - 2018 - Prevalence of confusing code in software projects.pdf:application/pdf}
}

@inproceedings{yeh_detecting_2017,
	address = {Indianapolis, IN},
	title = {Detecting and comparing brain activity in short program comprehension using {EEG}},
	isbn = {978-1-5090-5920-1},
	url = {http://ieeexplore.ieee.org/document/8190486/},
	doi = {10.1109/FIE.2017.8190486},
	abstract = {Program comprehension is a common task in software development. Programmers perform program comprehension at different stages of the software development life cycle. Detecting when a programmer experiences problems or confusion can be difficult. Self-reported data may be useful, but not reliable. More importantly, it is hard to use the self-reported feedback in real time.},
	language = {en},
	urldate = {2018-09-26},
	booktitle = {2017 {IEEE} {Frontiers} in {Education} {Conference} ({FIE})},
	publisher = {IEEE},
	author = {Yeh, Martin K.-C. and Gopstein, Dan and Yan, Yu and Zhuang, Yanyan},
	month = oct,
	year = {2017},
	pages = {1--5},
	file = {Yeh et al. - 2017 - Detecting and comparing brain activity in short pr.pdf:C\:\\Users\\Charles\\Zotero\\storage\\HY6P9TJI\\Yeh et al. - 2017 - Detecting and comparing brain activity in short pr.pdf:application/pdf}
}

@article{brooks_towards_1983,
	title = {Towards a theory of the comprehension of computer programs},
	volume = {18},
	issn = {00207373},
	url = {http://linkinghub.elsevier.com/retrieve/pii/S0020737383800315},
	doi = {10.1016/S0020-7373(83)80031-5},
	language = {en},
	number = {6},
	urldate = {2018-09-27},
	journal = {International Journal of Man-Machine Studies},
	author = {Brooks, Ruven},
	month = jun,
	year = {1983},
	pages = {543--554},
	file = {Brooks - 1983 - Towards a theory of the comprehension of computer .pdf:C\:\\Users\\Charles\\Zotero\\storage\\ZB5XY5I8\\Brooks - 1983 - Towards a theory of the comprehension of computer .pdf:application/pdf}
}

@article{maalej_comprehension_2014,
	title = {On the {Comprehension} of {Program} {Comprehension}},
	volume = {23},
	issn = {1049331X},
	url = {http://dl.acm.org/citation.cfm?doid=2668018.2622669},
	doi = {10.1145/2622669},
	language = {en},
	number = {4},
	urldate = {2018-09-27},
	journal = {ACM Transactions on Software Engineering and Methodology},
	author = {Maalej, Walid and Tiarks, Rebecca and Roehm, Tobias and Koschke, Rainer},
	month = sep,
	year = {2014},
	pages = {1--37},
	file = {Maalej et al. - 2014 - On the Comprehension of Program Comprehension.pdf:C\:\\Users\\Charles\\Zotero\\storage\\8YPUSHYV\\Maalej et al. - 2014 - On the Comprehension of Program Comprehension.pdf:application/pdf}
}

@inproceedings{roehm_how_2012,
	address = {Zurich},
	title = {How do professional developers comprehend software?},
	isbn = {978-1-4673-1066-6 978-1-4673-1067-3},
	url = {http://ieeexplore.ieee.org/document/6227188/},
	doi = {10.1109/ICSE.2012.6227188},
	abstract = {Research in program comprehension has considerably evolved over the past two decades. However, only little is known about how developers practice program comprehension under time and project pressure, and which methods and tools proposed by researchers are used in industry. This paper reports on an observational study of 28 professional developers from seven companies, investigating how developers comprehend software. In particular we focus on the strategies followed, information needed, and tools used.},
	language = {en},
	urldate = {2018-09-27},
	booktitle = {2012 34th {International} {Conference} on {Software} {Engineering} ({ICSE})},
	publisher = {IEEE},
	author = {Roehm, Tobias and Tiarks, Rebecca and Koschke, Rainer and Maalej, Walid},
	month = jun,
	year = {2012},
	pages = {255--265},
	file = {Roehm et al. - 2012 - How do professional developers comprehend software.pdf:C\:\\Users\\Charles\\Zotero\\storage\\XYM2GXU3\\Roehm et al. - 2012 - How do professional developers comprehend software.pdf:application/pdf}
}

@inproceedings{abbes_empirical_2011,
	title = {An {Empirical} {Study} of the {Impact} of {Two} {Antipatterns}, {Blob} and {Spaghetti} {Code}, on {Program} {Comprehension}},
	doi = {10.1109/CSMR.2011.24},
	abstract = {Antipatterns are "poor" solutions to recurring design problems which are conjectured in the literature to make object-oriented systems harder to maintain. However, little quantitative evidence exists to support this conjecture. We performed an empirical study to investigate whether the occurrence of antipatterns does indeed affect the understandability of systems by developers during comprehension and maintenance tasks. We designed and conducted three experiments, with 24 subjects each, to collect data on the performance of developers on basic tasks related to program comprehension and assessed the impact of two antipatterns and of their combinations: Blob and Spaghetti Code. We measured the developers' performance with: (1) the NASA task load index for their effort, (2) the time that they spent performing their tasks, and, (3) their percentages of correct answers. Collected data show that the occurrence of one antipattern does not significantly decrease developers' performance while the combination of two antipatterns impedes significantly developers. We conclude that developers can cope with one antipattern but that combinations of antipatterns should be avoided possibly through detection and refactorings.},
	booktitle = {2011 15th {European} {Conference} on {Software} {Maintenance} and {Reengineering}},
	author = {Abbes, M. and Khomh, F. and Gueheneuc, Y. and Antoniol, G.},
	month = mar,
	year = {2011},
	keywords = {Java, object-oriented programming, object-oriented systems, software maintenance, program comprehension, Programming, Maintenance engineering, Analysis of variance, antipatterns, Antipatterns, blob, Blob, Empirical Software Engineering, Indexes, maintenance tasks, NASA, NASA task load index, Program Comprehension, Program Maintenance, recurring design problems, spaghetti code, Spaghetti Code, Time measurement},
	pages = {181--190},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Charles\\Zotero\\storage\\4ASRU55D\\5741260.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Charles\\Zotero\\storage\\EHQRG747\\Abbes et al. - 2011 - An Empirical Study of the Impact of Two Antipatter.pdf:application/pdf}
}

@inproceedings{nakagawa_quantifying_2014,
	address = {Hyderabad, India},
	title = {Quantifying programmers' mental workload during program comprehension based on cerebral blood flow measurement: a controlled experiment},
	isbn = {978-1-4503-2768-8},
	shorttitle = {Quantifying programmers' mental workload during program comprehension based on cerebral blood flow measurement},
	url = {http://dl.acm.org/citation.cfm?doid=2591062.2591098},
	doi = {10.1145/2591062.2591098},
	abstract = {Program comprehension is a fundamental activity in software development that cannot be easily measured, as it is performed inside the human brain. Using a wearable Near Infra-red Spectroscopy (NIRS) device to measure cerebral blood ﬂow, this paper tries to answer the question: Can the measurement of brain blood-ﬂow quantify programmers’ mental workload during program comprehension activities? We performed a controlled experiment with 10 subjects; 8 of them showed high cerebral blood ﬂow while understanding strongly obfuscated programs (requiring high mental workload). This suggests the possibility of using NIRS to measure the mental workload of a person during software development activities.},
	language = {en},
	urldate = {2018-09-27},
	booktitle = {Companion {Proceedings} of the 36th {International} {Conference} on {Software} {Engineering} - {ICSE} {Companion} 2014},
	publisher = {ACM Press},
	author = {Nakagawa, Takao and Kamei, Yasutaka and Uwano, Hidetake and Monden, Akito and Matsumoto, Kenichi and German, Daniel M.},
	year = {2014},
	pages = {448--451},
	file = {Nakagawa et al. - 2014 - Quantifying programmers' mental workload during pr.pdf:C\:\\Users\\Charles\\Zotero\\storage\\KGLSDGLH\\Nakagawa et al. - 2014 - Quantifying programmers' mental workload during pr.pdf:application/pdf}
}

@article{spinellis_evaluating_2009,
	series = {Proceedings of the {International} {Workshop} on {Software} {Quality} and {Maintainability} ({SQM} 2008)},
	title = {Evaluating the {Quality} of {Open} {Source} {Software}},
	volume = {233},
	issn = {1571-0661},
	url = {http://www.sciencedirect.com/science/article/pii/S1571066109000632},
	doi = {10.1016/j.entcs.2009.02.058},
	abstract = {Traditionally, research on quality attributes was either kept under wraps within the organization that performed it, or carried out by outsiders using narrow, black-box techniques. The emergence of open source software has changed this picture allowing us to evaluate both software products and the processes that yield them. Thus, the software source code and the associated data stored in the version control system, the bug tracking databases, the mailing lists, and the wikis allow us to evaluate quality in a transparent way. Even better, the large number of (often competing) open source projects makes it possible to contrast the quality of comparable systems serving the same domain. Furthermore, by combining historical source code snapshots with significant events, such as bug discoveries and fixes, we can further dig into the causes and effects of problems. Here we present motivating examples, tools, and techniques that can be used to evaluate the quality of open source (and by extension also proprietary) software.},
	urldate = {2018-09-27},
	journal = {Electronic Notes in Theoretical Computer Science},
	author = {Spinellis, Diomidis and Gousios, Georgios and Karakoidas, Vassilios and Louridas, Panagiotis and Adams, Paul J. and Samoladas, Ioannis and Stamelos, Ioannis},
	month = mar,
	year = {2009},
	keywords = {open source, process quality attributes, product quality attributes},
	pages = {5--28},
	file = {ScienceDirect Full Text PDF:C\:\\Users\\Charles\\Zotero\\storage\\RXCNCQI6\\Spinellis et al. - 2009 - Evaluating the Quality of Open Source Software.pdf:application/pdf;ScienceDirect Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\DPTCM3UN\\S1571066109000632.html:text/html}
}

@inproceedings{siegmund_understanding_2014,
	address = {Hyderabad, India},
	title = {Understanding understanding source code with functional magnetic resonance imaging},
	isbn = {978-1-4503-2756-5},
	url = {http://dl.acm.org/citation.cfm?doid=2568225.2568252},
	doi = {10.1145/2568225.2568252},
	language = {en},
	urldate = {2018-09-27},
	booktitle = {Proceedings of the 36th {International} {Conference} on {Software} {Engineering} - {ICSE} 2014},
	publisher = {ACM Press},
	author = {Siegmund, Janet and Kästner, Christian and Apel, Sven and Parnin, Chris and Bethmann, Anja and Leich, Thomas and Saake, Gunter and Brechmann, André},
	year = {2014},
	pages = {378--389},
	file = {Siegmund et al. - 2014 - Understanding understanding source code with funct.pdf:C\:\\Users\\Charles\\Zotero\\storage\\HBDRTMR4\\Siegmund et al. - 2014 - Understanding understanding source code with funct.pdf:application/pdf}
}

@inproceedings{posnett_simpler_2011,
	address = {Waikiki, Honolulu, HI, USA},
	title = {A simpler model of software readability},
	isbn = {978-1-4503-0574-7},
	url = {http://portal.acm.org/citation.cfm?doid=1985441.1985454},
	doi = {10.1145/1985441.1985454},
	abstract = {Software readability is a property that inﬂuences how easily a given piece of code can be read and understood. Since readability can aﬀect maintainability, quality, etc., programmers are very concerned about the readability of code. If automatic readability checkers could be built, they could be integrated into development tool-chains, and thus continually inform developers about the readability level of the code. Unfortunately, readability is a subjective code property, and not amenable to direct automated measurement. In a recently published study, Buse et al. asked 100 participants to rate code snippets by readability, yielding arguably reliable mean readability scores of each snippet; they then built a fairly complex predictive model for these mean scores using a large, diverse set of directly measurable source code properties. We build on this work: we present a simple, intuitive theory of readability, based on size and code entropy, and show how this theory leads to a much sparser, yet statistically signiﬁcant, model of the mean readability scores produced in Buse’s studies. Our model uses well-known size metrics and Halstead metrics, which are easily extracted using a variety of tools. We argue that this approach provides a more theoretically well-founded, practically usable, approach to readability measurement.},
	language = {en},
	urldate = {2018-09-27},
	booktitle = {Proceeding of the 8th working conference on {Mining} software repositories - {MSR} '11},
	publisher = {ACM Press},
	author = {Posnett, Daryl and Hindle, Abram and Devanbu, Premkumar},
	year = {2011},
	pages = {73},
	file = {Posnett et al. - 2011 - A simpler model of software readability.pdf:C\:\\Users\\Charles\\Zotero\\storage\\HMD67G26\\Posnett et al. - 2011 - A simpler model of software readability.pdf:application/pdf}
}

@inproceedings{buse_metric_2008,
	title = {A metric for software readability},
	booktitle = {Proceedings of the 2008 international symposium on {Software} testing and analysis},
	publisher = {ACM},
	author = {Buse, Raymond PL and Weimer, Westley R.},
	year = {2008},
	pages = {121--130},
	file = {Fulltext:C\:\\Users\\Charles\\Zotero\\storage\\TDIDMKAE\\Buse and Weimer - 2008 - A metric for software readability.pdf:application/pdf;Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\Q66EJXRA\\Buse and Weimer - 2008 - A metric for software readability.pdf:application/pdf}
}

@inproceedings{butler_relating_2009,
	title = {Relating identifier naming flaws and code quality: {An} empirical study},
	shorttitle = {Relating identifier naming flaws and code quality},
	booktitle = {Reverse {Engineering}, 2009. {WCRE}'09. 16th {Working} {Conference} on},
	publisher = {IEEE},
	author = {Butler, Simon and Wermelinger, Michel and Yu, Yijun and Sharp, Helen},
	year = {2009},
	pages = {31--35},
	file = {Fulltext:C\:\\Users\\Charles\\Zotero\\storage\\ZJMAHVWP\\Butler et al. - 2009 - Relating identifier naming flaws and code quality.pdf:application/pdf;Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\IXVY44T9\\5328661.html:text/html}
}

@article{buse_learning_2010,
	title = {Learning a metric for code readability},
	volume = {36},
	number = {4},
	journal = {IEEE Transactions on Software Engineering},
	author = {Buse, Raymond PL and Weimer, Westley R.},
	year = {2010},
	pages = {546--558},
	file = {Fulltext:C\:\\Users\\Charles\\Zotero\\storage\\8R7DL7JM\\Buse and Weimer - 2010 - Learning a metric for code readability.pdf:application/pdf;Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\8PTCMXRJ\\5332232.html:text/html}
}

@inproceedings{butler_exploring_2010,
	title = {Exploring the influence of identifier names on code quality: {An} empirical study},
	shorttitle = {Exploring the influence of identifier names on code quality},
	booktitle = {Software {Maintenance} and {Reengineering} ({CSMR}), 2010 14th {European} {Conference} on},
	publisher = {IEEE},
	author = {Butler, Simon and Wermelinger, Michel and Yu, Yijun and Sharp, Helen},
	year = {2010},
	pages = {156--165},
	file = {Fulltext:C\:\\Users\\Charles\\Zotero\\storage\\7CYPZX3P\\Butler et al. - 2010 - Exploring the influence of identifier names on cod.pdf:application/pdf;Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\2Q3V6B47\\5714430.html:text/html}
}

@inproceedings{smit_code_2011,
	title = {Code convention adherence in evolving software},
	booktitle = {Software {Maintenance} ({ICSM}), 2011 27th {IEEE} {International} {Conference} on},
	publisher = {IEEE},
	author = {Smit, Michael and Gergel, Barry and Hoover, H. James and Stroulia, Eleni},
	year = {2011},
	pages = {504--507},
	file = {Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\4DAI5RG4\\6080819.html:text/html}
}

@inproceedings{wang_automatic_2011,
	title = {Automatic segmentation of method code into meaningful blocks to improve readability},
	booktitle = {Reverse {Engineering} ({WCRE}), 2011 18th {Working} {Conference} on},
	publisher = {IEEE},
	author = {Wang, Xiaoran and Pollock, Lori and Vijay-Shanker, K.},
	year = {2011},
	pages = {35--44},
	file = {Fulltext:C\:\\Users\\Charles\\Zotero\\storage\\HCSRI5IW\\Wang et al. - 2011 - Automatic segmentation of method code into meaning.pdf:application/pdf;Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\KHBXFY7Z\\6079773.html:text/html}
}

@inproceedings{relf_tool_2005,
	title = {Tool assisted identifier naming for improved software readability: an empirical study},
	shorttitle = {Tool assisted identifier naming for improved software readability},
	doi = {10.1109/ISESE.2005.1541814},
	abstract = {This paper describes an empirical study investigating whether programmers improve the readability of their source code if they have support from a source code editor that offers dynamic feedback on their identifier naming practices. An experiment, employing both students and professional software engineers, and requiring the maintenance and production of software, demonstrated a statistically significant improvement in source code readability over that of the control.},
	booktitle = {2005 {International} {Symposium} on {Empirical} {Software} {Engineering}, 2005.},
	author = {Relf, P. A.},
	month = nov,
	year = {2005},
	keywords = {Software tools, software maintenance, statistical analysis, software engineering, Programming profession, Software maintenance, Australia, Costs, Cultural differences, dynamic feedback, empirical analysis, Feedback, Guidelines, Production, software production, software readability, source code editor, source code readability, tool assisted identifier naming, Writing},
	pages = {10 pp.--},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Charles\\Zotero\\storage\\4PQX5V6U\\1541814.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Charles\\Zotero\\storage\\GL3SBTKV\\Relf - 2005 - Tool assisted identifier naming for improved softw.pdf:application/pdf}
}

@article{zokaites_writing_2002,
	title = {Writing understandable code},
	volume = {10},
	number = {1},
	journal = {SOFTWARE DEVELOPMENT-SAN FRANCISCO-},
	author = {Zokaites, David Michael},
	year = {2002},
	pages = {48--50},
	file = {Fulltext:C\:\\Users\\Charles\\Zotero\\storage\\T7ACIX45\\Zokaites - 2002 - Writing understandable code.pdf:application/pdf;Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\F8E8FBMC\\Zokaites - 2002 - Writing understandable code.pdf:application/pdf}
}

@article{dambros_evaluating_2012,
	title = {Evaluating defect prediction approaches: a benchmark and an extensive comparison},
	volume = {17},
	shorttitle = {Evaluating defect prediction approaches},
	number = {4-5},
	journal = {Empirical Software Engineering},
	author = {D’Ambros, Marco and Lanza, Michele and Robbes, Romain},
	year = {2012},
	pages = {531--577},
	file = {Fulltext:C\:\\Users\\Charles\\Zotero\\storage\\WJVNZEB5\\D’Ambros et al. - 2012 - Evaluating defect prediction approaches a benchma.pdf:application/pdf;Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\YJRIBMHB\\s10664-011-9173-9.html:text/html}
}

@article{hang_google_nodate,
	title = {Google {C}++ {Style} {Guide}},
	language = {en},
	author = {Hang, XIAO and Student, Ph D and Axel, Group},
	pages = {46},
	file = {Hang et al. - Google C++ Style Guide.pdf:C\:\\Users\\Charles\\Zotero\\storage\\5TRCV8QW\\Hang et al. - Google C++ Style Guide.pdf:application/pdf}
}

@article{doland_c_1994,
	title = {C style guide ({NASA})},
	author = {Doland, Jerry and Valett, Jon},
	year = {1994},
	file = {Fulltext:C\:\\Users\\Charles\\Zotero\\storage\\6AKYL8BX\\Doland and Valett - 1994 - C style guide.pdf:application/pdf;Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\BDTBQ9GD\\search.html:text/html}
}

@article{torvalds_linux_nodate,
	title = {Linux kernel coding style},
	language = {en},
	author = {Torvalds, Linus},
	pages = {6},
	file = {Torvalds - Linux kernel coding style.pdf:C\:\\Users\\Charles\\Zotero\\storage\\XD5P8CXH\\Torvalds - Linux kernel coding style.pdf:application/pdf}
}

@book{wroblewski_general_2002,
	title = {General {Method} of {Program} {Code} {Obfuscation}},
	abstract = {vii},
	author = {Wroblewski, Gregory},
	year = {2002},
	file = {Citeseer - Full Text PDF:C\:\\Users\\Charles\\Zotero\\storage\\G4UKR3JH\\Wroblewski - 2002 - General Method of Program Code Obfuscation.pdf:application/pdf;Citeseer - Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\LQYDAUKC\\summary.html:text/html}
}